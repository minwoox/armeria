import groovy.json.JsonBuilder

import java.nio.file.Files
import java.util.stream.Collectors
import java.util.stream.Stream

buildscript {
    repositories {
        gradlePluginPortal()
        mavenCentral()
    }
    dependencies {
        classpath "com.github.node-gradle:gradle-node-plugin:${managedVersions['com.github.node-gradle:gradle-node-plugin']}"
    }
}

apply plugin: 'base'
apply plugin: 'com.github.node-gradle.node'

tasks.yarn {
    args += ['--frozen-lockfile']

    // gradle-node-plugin sets node_modules as an output directory for up-to-date checking.
    // This makes sense in principal but Gradle often handles up-to-date checking much more
    // slowly than yarn itself for a large node_modules, so we go ahead and remove it all
    // from up-to-date checking.
    nodeModulesOutputFilter = {
        it.exclude("**/*")
    }
}

task yarnClean(type: YarnTask) {
    dependsOn 'yarn'
    args = ['run', 'clean']
}
tasks.clean.dependsOn tasks.yarnClean
tasks.clean.delete(project.file("${project.projectDir}/gen-src"))

task versionIndex(type: VersionIndexTask)
task apiIndex(type: ApiIndexTask) {
    dependsOn ':javadoc:javadoc'
}
task prepare {
    dependsOn tasks.yarn
    dependsOn tasks.versionIndex
    dependsOn tasks.apiIndex
}

task develop(type: YarnTask) {
    dependsOn tasks.prepare
    dependsOn 'yarn'

    args = ['run', 'develop']
}

final def checkstyleEnabled = !rootProject.hasProperty('noCheckstyle')
if (checkstyleEnabled) {
    task lint(type: YarnTask) {
        dependsOn 'yarn'
        args = ['run', 'lint']
        inputs.dir('src')
        inputs.file('.eslintrc.js')
        inputs.file('package.json')
        inputs.file('yarn.lock')
    }
}

task site(type: YarnTask) {
    dependsOn tasks.prepare
    dependsOn 'yarn'

    if (checkstyleEnabled) {
        dependsOn 'lint'
    }
    args = ['run', 'build']
    inputs.dir('src')
    inputs.file('gatsby-config.js')
    inputs.file('package.json')
    inputs.file('tsconfig.json')
    inputs.file('yarn.lock')
    outputs.dir('.cache')
    outputs.dir('public')
}
tasks.build.dependsOn tasks.site

node {
    version = '12.16.1'
    yarnVersion = '1.22.4'
    download = true
}

class VersionIndexTask extends DefaultTask {

    @Input
    final def version = project.property('version')
    @Input
    final def managedVersions = project.property('managedVersions') as Map
    @OutputFile
    final def versionIndexFile = project.file("${project.projectDir}/gen-src/versions.json")

    @TaskAction
    def run() {
        def info = new TreeMap(this.managedVersions)
        info["${project.group}:armeria-bom"] = version

        versionIndexFile.withPrintWriter('UTF-8') { out ->
            out.println(new JsonBuilder(info).toPrettyString())
        }
    }
}

class ApiIndexTask extends DefaultTask {

    @InputDirectory
    final def javadocDir = project.file("${project.rootProject.projectDir}/javadoc/build/docs/javadoc")
    @OutputFile
    final def nameToHrefIdFile = project.file("${project.projectDir}/gen-src/api-index/name-to-href-id.json")
    @OutputFile
    final def hrefsFile = project.file("${project.projectDir}/gen-src/api-index/hrefs.json")

    @TaskAction
    def run() {
        def javadocPath = javadocDir.toPath()
        def nextHrefId = 0
        def hrefs = []
        def nameToHrefId = Files.walk(javadocPath).filter({ path ->
            if (Files.isDirectory(path)) {
                return false
            }

            return path.getName(path.nameCount - 1).toString().matches(/[A-Z][a-zA-Z0-9._$]+\.html/)
        }).sorted().flatMap({ path ->
            def baseName = path.getName(path.nameCount - 1).toString()
            def simpleClassName = baseName[0..-6]
            def relativePathStr = "${javadocPath.relativize(path)}".replace(File.separator, '/')
            def fqcn = relativePathStr[0..-6].replace('/', '.')
            def href = "https://javadoc.io/doc/com.linecorp.armeria/armeria-javadoc/latest/${relativePathStr}"
            def hrefId = nextHrefId++

            hrefs[hrefId] = href

            def packagePrefix = 'com.linecorp.armeria.'
            if (!fqcn.startsWith(packagePrefix)) {
                return Stream.of(
                        [simpleClassName, hrefId],
                        [fqcn, hrefId])
            } else {
                return Stream.of(
                        [simpleClassName, hrefId],
                        [fqcn.substring(packagePrefix.length()), hrefId],
                        [fqcn, hrefId])
            }
        }).collect(Collectors.toMap({ e -> e[0] }, { e -> e[1] }, { a, b -> a }, { new TreeMap()}))


        nameToHrefIdFile.withPrintWriter('UTF-8') { out ->
            out.println(new JsonBuilder(nameToHrefId).toPrettyString())
        }

        hrefsFile.withPrintWriter('UTF-8') { out ->
            out.println(new JsonBuilder(hrefs).toPrettyString())
        }
    }
}
